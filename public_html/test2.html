<!DOCTYPE html>
<meta charset="utf-8">
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

  <script>
    // Define dimensions
    var width = window.innerWidth, height = 800;
    var numCircles = 500;
    var initialRadius = 15;
    var targetRadius = 10;
    var padding = 2;
    var rectWidth = 100, rectHeight = 300;
    var animationDuration = 0.85;

    // Rectangle positions
    var rect1 = { x: 50, y: 50, width: rectWidth, height: rectHeight };
    var rect2 = { x: width - 150, y: 50, width: rectWidth, height: rectHeight };

    // Create a shuffled array of assignments
    var assignments = Array(Math.floor(numCircles / 2)).fill(rect1).concat(Array(Math.ceil(numCircles / 2)).fill(rect2));
    assignments = d3.shuffle(assignments);

    // Generate random circles data
    var circlesData = d3.range(numCircles).map((d, i) => ({
        id: i,
        radius: Math.random() * 20 + 5,
        x: 0,
        y: 0,
        fill: "steelblue",
        initialX: 0,
        initialY: 0,
        targetX: 0,
        targetY: 0,
        rect: assignments[i]
    }));

    // Create the SVG container
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    // Pack circles in a circular layout
    var pack = d3.pack()
        .size([width, height])
        .padding(padding);

    var root = d3.hierarchy({ children: circlesData })
        .sum(d => d.radius * d.radius);

    pack(root);

    circlesData.forEach((d, i) => {
        d.x = root.children[i].x;
        d.y = root.children[i].y;
        d.initialX = d.x;
        d.initialY = d.y;
        d.radius = root.children[i].r;
        d.r = root.children[i].r;
        d.scale = 1;
        d.opacity = 1;
    });

    // Calculate target positions for the rectangular layout
    function calculateRectPositions(rect, data) {
        var columns = Math.floor(rect.width / (targetRadius * 2 + padding));
        var rows = Math.floor(rect.height / (targetRadius * 2 + padding));

        data.forEach((d, i) => {
            var col = i % columns;
            var row = Math.floor(i / columns);
            d.targetX = rect.x + col * (targetRadius * 2 + padding) + targetRadius + padding;
            d.targetY = rect.y + row * (targetRadius * 2 + padding) + targetRadius + padding;
        });
    }

    // Separate data into two groups based on the rectangle assignment
    var rect1Data = circlesData.filter(d => d.rect === rect1);
    var rect2Data = circlesData.filter(d => d.rect === rect2);

    calculateRectPositions(rect1, rect1Data);
    calculateRectPositions(rect2, rect2Data);

    // Shuffle circlesData to ensure random animation order
    circlesData = d3.shuffle(circlesData);

    // Add circles to the SVG
    svg.selectAll("circle")
        .data(circlesData)
        .enter().append("circle")
        .attr("r", d => d.radius)
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("fill", d => d.fill);

    // GSAP timeline for animation
    var tl = gsap.timeline({ paused: true, reversed: true });

    tl.to(circlesData, {
        x: (index) => circlesData[index].targetX,
        y: (index) => circlesData[index].targetY,
        scale: (index) => targetRadius / circlesData[index].radius,
        r: (index) => circlesData[index].radius,
        duration: animationDuration,
        ease: "back.out(1.4)",
        stagger: { amount: 2 / 3 },
        onUpdate: () => {
            drawCirclesAndLabels(circlesData);
        }
    });

    // Function to draw circles and labels
    function drawCirclesAndLabels(circlesData) {
        svg.selectAll('circle')
            .data(circlesData, d => d.id)
            .attr('cx', d => d.x)
            .attr('cy', d => d.y)
            .attr('r', d => {
                const radius = isNaN(d.r) ? 1 : d.r; // Default radius to 1 if d.r is NaN
                const scale = isNaN(d.scale) ? 1 : d.scale; // Default scale to 1 if d.scale is NaN
                return Math.max(radius * scale - padding, 1); // Ensure radius is not negative
            })
            .attr('fill', d => d.fill)
            .attr('opacity', d => d.opacity)
            .attr('stroke', d => d.fill); // Update stroke color
    }

    // Add button to trigger the packing animation
    d3.select("body").append("button")
        .text("Pack in Rectangles")
        .on("click", function () {
            tl.vars.ease = "back.in(1.4)";
            tl.play();
        });

    // Add button to reverse the packing animation
    d3.select("body").append("button")
        .text("Reverse Packing")
        .on("click", function () {
            tl.vars.ease = "back.out(1.4)";
            tl.reverse();
        });

  </script>
</body>
